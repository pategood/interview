发送端 发送一个带有SYN标志的数据包给 接收端

第一次握手: 客户端发送一个带有SYN标志的数据包给服务器,然后等待回复

第二次握手: 服务器收到数据包后返回一个带有SYN ACK标志的数据包 表示 能正常接收到数据

第三次握手: 客户端接收到数据包后发送一个带有ACK标志的数据包 





第一次握手:
    客户端 发送syn(syn=1)  随机产生seq number=1234567的数据包到服务器
    服务器 收到syn(syn=1) 知道客户端要 建立连接

第二次握手:
    服务器收到请求后,向客户端发送ack( 客户端的 seq +1 )




SYN表示建立连接，ACK表示响应，
单个的一个SYN，它表示的只是建立连接。
当出现SYN和SYN＋ACK包时，我们认为客户端与服务器建立了一个连接

https://img2020.cnblogs.com/blog/1867105/202004/1867105-20200407232255066-899507589.png










前两次握手: 判断客户端与服务器是否可以正常通讯
前两次握手都是在请求建立连接，所以不能携带数据

第三次才开始发送



为什么三次握手?

3次握手保证了双方都能正常发送数据,且接收数据



为什么不能两次握手?
  可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，
  不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。
  在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，
  只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。
  这样就形成了死锁。