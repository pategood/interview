发送端 发送一个带有SYN标志的数据包给 接收端

第一次握手: 客户端发送一个带有SYN标志的数据包给服务器,然后等待回复   

第二次握手: 服务器收到数据包后返回一个带有SYN ACK标志的数据包 表示 服务器能正常接收到客户端的数据

第三次握手: 客户端接收到数据包后发送一个带有ACK标志的数据包     表示 客户端能收到服务器的数据

SYN表示建立连接，ACK表示响应，
前两次握手: 判断客户端与服务器是否可以正常通讯
前两次握手都是在请求建立连接，所以不能携带数据


为什么三次握手?而不是两次
如果二次握手:
  假如第一次握手发送的数据包因为网络延迟等原因 滞留在某个网络结点，
  超出等待时间后客户端重新发起握手请求,如果中途之前滞留的握手请求又好了,送到服务器后,
   服务器发起第二次握手,并确定建立连接,拒绝接收其他第一次握手的请求,等待接收数据
  而客户端接收后比对,发现seq不对,则,继续等待,第二次握手请求  两边都在等待,形成死锁


http的keep-alive作用是避免进行重复的TCP三次握手和四次挥手的环节

一旦客户端发送connection:keep-alive头给服务端，且服务端也接受这个keep-alive的话，
两边对上暗号，这个连接就可以复用了，一个http处理完之后，另外一个http数据直接从这个连接走了。
减少新建和断开TCP连接的消耗。

http1.1时最多发起16个请求


详细一点：

  第一次握手:
      客户端 发送syn=1  随机产生seq number=1234567的数据包 到服务器
      (服务器 收到syn=1 知道客户端要 建立连接)

  第二次握手:
      服务器收到 数据包后,向客户端发送syn=1，ack=1 , ack number (ack number= 客户端seq+1)
      随机产生seq=7654321的包

  第三次握手: 
      客户端 收到后 检查ack number是否正确  以及ack是否为1 
        正确则 发送ack number=服务器的seq +1  ,ack=1 
      
      服务器收到后 确认 seq值与ack=1 确认正确后 建立连接成功







SYN表示建立连接，ACK表示响应，
单个的一个SYN，它表示的只是建立连接。
当出现SYN和SYN＋ACK包时，我们认为客户端与服务器建立了一个连接

https://img2020.cnblogs.com/blog/1867105/202004/1867105-20200407232255066-899507589.png









为什么三次握手?

3次握手保证了双方都能正常发送数据,且接收数据
本质原因是 ：信道不可靠, 所以要保证 数据传输要可靠



为什么不能两次握手?
  可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，
  不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。
  在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，
  只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。
  这样就形成了死锁。

  假如第二次握手的数据包丢失,则客户端无法确认服务器是否准备好 
  会等待接收第二次握手的数据包