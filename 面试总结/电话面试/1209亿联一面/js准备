let const var 区别
  let  存在块级作用域   不能重复声明，存在暂时性死区，不会被提升
  const 基本和let一样，不同的是 const是常量被修改，复杂类型的变量名是指想数据的地址，可修改复杂类型的数据
  var 创建和初始化都提升了
  function创建初始化  赋值都提升了

什么是闭包
  定义在函数内部的函数，外界可通过调用函数内部的函数来访问定义函数时的函数上下文（局部作用域）  
  特点：
    变量无法被释放  无法被直接访问；闭包可以被延迟执行。
  缺点:
    会造成内存泄漏，分配的空间无法被回收，循环引用后占用大量内存

  例子： 
    vue组件内的data函数，data返回的数据形成闭包,类似于私有属性，每个data数据都是独立的
  应用场景：
    可以用来定义私有属性和私有方法 

垃圾回收机制
  标记清除  和 引用记数

  没有被引用的对象就是垃圾,根访问不到它们

  解决内存泄漏

es6 数组api


节流防抖
  节流是 函数频繁触发，设置定时器隔几秒执行一次，
  防抖是 函数频繁触发，最后一次触发过几秒后在执行

  节流 应用 
    下拉列表

  防抖应用：
    输入框

  防抖:
    效果：持续触发某一事件的时候，函数不执行，等最后一次触发结束的一段时间之后，再去执行

  节流:
    在一段时间内，只执行一次。
    持续触发并不会执行多次
    到一定时间再去执行



原型链
  当我们访问实例对象的属性时，如果没有找到属性，会顺着_proto_去他的构造函数的上找，如果还没找到

  介绍：
    每一个函数都有一个prototype属性，这个属性指向函数的原型对象，这个对象包含了所有实例对象共享的属性和方法，而每一个实例对象的_proto_都指向这个构造函数的原型，而这个原型可能是被另一个构造函数实例出来的对象  顺着_proto_一直找到js的Object的原型，还没找到就会通过_proto_找到null停下来



import 和 require  
  import最终会被编译为require
  import静态编译  require一般用在动态加载
  
  node支持require  vue的import最终编译为require

  import 是在编译过程中执行，而common的require是同步。

  import传的是值引用，require是值拷贝。